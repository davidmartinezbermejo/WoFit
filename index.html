<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>FIT Sync Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #map {
            height: 40vh;
            width: 100%;
            background: #ddd;
        }

        .chart-container {
            flex: 1;
            padding: 10px;
            background: white;
            min-height: 0;
        }

        #metrics {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 11px;
            background: #34495e;
            padding: 8px;
            border-radius: 4px;
        }

        .metric-item {
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid #555;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .square {
            width: 10px;
            height: 10px;
            border: 1px solid white;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="controls">
            F1: <input type="file" id="file1" style="width:130px">
            F2: <input type="file" id="file2" style="width:130px">
            Offset F2: <input type="number" id="offset" value="0" style="width:60px">
        </div>
        <div id="metrics"></div>
    </div>
    <div id="map"></div>
    <div class="chart-container"><canvas id="mainChart"></canvas></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>

    <script type="module">
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
        }

        import { Decoder, Stream } from 'https://cdn.jsdelivr.net/npm/@garmin/fitsdk@21.126.0/+esm';

        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        let chart;
        let dataStore = { f1: [], f2: [] };
        const paramColors = {
            heartRate: '#ff0000', speed: '#0000ff', cadence: '#ffff00',
            power: '#a020f0', altitude: '#00ff00'
        };

        const layers = { f1: L.featureGroup().addTo(map), f2: L.featureGroup().addTo(map) };
        const cursorMarkers = {
            f1: L.circleMarker([0, 0], { color: 'blue', radius: 6, fillOpacity: 1, interactive: false }).addTo(map),
            f2: L.circleMarker([0, 0], { color: 'red', radius: 6, fillOpacity: 1, interactive: false }).addTo(map)
        };

        const ctx = document.getElementById('mainChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: { datasets: [] },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    x: {
                        type: 'linear',
                        ticks: {
                            // Convierte los segundos del eje X a HH:mm:ss
                            callback: (value) => formatTime(value)
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            // Cambia el título del tooltip a HH:mm:ss
                            title: (items) => formatTime(items[0].parsed.x),
                            afterBody: (items) => {
                                moveCursors(items[0].parsed.x);
                                return "";
                            }
                        }
                    }
                }
            },
            plugins: [{
                id: 'crosshair',
                afterDraw: (chart) => {
                    if (chart.tooltip?._active?.length) {
                        const x = chart.tooltip._active[0].element.x;
                        const ctx = chart.ctx;
                        ctx.save(); ctx.beginPath();
                        ctx.moveTo(x, chart.chartArea.top);
                        ctx.lineTo(x, chart.chartArea.bottom);
                        ctx.lineWidth = 1; ctx.strokeStyle = '#666'; ctx.setLineDash([3, 3]);
                        ctx.stroke(); ctx.restore();
                    }
                }
            }]
        });

        async function processFit(file, key) {
            if (!file) return;
            const buffer = await file.arrayBuffer();
            const decoder = new Decoder(Stream.fromByteArray(new Uint8Array(buffer)));
            const { messages } = decoder.read();
            const records = (messages.recordMesgs || []).filter(m => m.positionLat);
            if (records.length === 0) return;

            const startT = records[0].timestamp.getTime();
            dataStore[key] = records.map(m => {
                const obj = {
                    t: (m.timestamp.getTime() - startT) / 1000,
                    lat: m.positionLat * (180 / Math.pow(2, 31)),
                    lng: m.positionLong * (180 / Math.pow(2, 31))
                };
                for (let k in m) { if (typeof m[k] === 'number') obj[k] = m[k]; }
                return obj;
            });

            drawRoute(key);
            buildMetricSelectors();
            updateChart();
        }

        function buildMetricSelectors() {
            const div = document.getElementById('metrics');
            const currentSelected = Array.from(div.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
            div.innerHTML = '';

            const allKeys = new Set();
            [...dataStore.f1, ...dataStore.f2].forEach(rec => {
                Object.keys(rec).forEach(k => { if (!['t', 'lat', 'lng'].includes(k)) allKeys.add(k); });
            });

            Array.from(allKeys).sort().forEach(m => {
                if (!paramColors[m]) paramColors[m] = '#999999';

                const span = document.createElement('span');
                span.className = 'metric-item';
                span.style.color = paramColors[m];

                span.innerHTML = `
                    <input type="checkbox" value="${m}" ${currentSelected.includes(m) || m === 'heartRate' ? 'checked' : ''}>
                    <input type="color" value="${paramColors[m]}" style="width:20px;height:20px;border:none;padding:0;background:none">
                    <span>${m}</span>
                `;

                const cb = span.querySelector('input[type="checkbox"]');
                const cp = span.querySelector('input[type="color"]');

                cb.onchange = updateChart;
                cp.oninput = (e) => {
                    paramColors[m] = e.target.value;
                    span.style.color = e.target.value;
                    updateChart();
                };

                div.appendChild(span);
            });
        }

        function updateChart() {
            const offset = parseFloat(document.getElementById('offset').value) || 0;
            const selected = Array.from(document.querySelectorAll('#metrics input[type="checkbox"]:checked')).map(i => i.value);

            chart.data.datasets = [];
            // Mantener el formato en el eje X al actualizar escalas
            const newScales = {
                x: {
                    type: 'linear',
                    ticks: { callback: (value) => formatTime(value) }
                }
            };

            selected.forEach((m, index) => {
                // ... (resto del código de selección de colores y ejes Y que ya tenías)
                const color = paramColors[m];
                newScales[m] = {
                    type: 'linear', display: true,
                    position: index % 2 === 0 ? 'left' : 'right',
                    title: { display: true, text: m, color: color },
                    ticks: { color: color },
                    grid: { drawOnChartArea: index === 0 }
                };

                if (dataStore.f1.length) {
                    chart.data.datasets.push({
                        label: `F1: ${m}`, data: dataStore.f1.map(d => ({ x: d.t, y: d[m] })),
                        borderColor: color, yAxisID: m, pointRadius: 0, borderWidth: 2
                    });
                }
                if (dataStore.f2.length) {
                    chart.data.datasets.push({
                        label: `F2: ${m}`, data: dataStore.f2.map(d => ({ x: d.t + offset, y: d[m] })),
                        borderColor: color, borderDash: [5, 5], yAxisID: m, pointRadius: 0, borderWidth: 2
                    });
                }
            });

            chart.options.scales = newScales;
            chart.update();
        }
        function drawRoute(key) {
            layers[key].clearLayers();
            const color = key === 'f1' ? 'blue' : 'red';
            const pts = dataStore[key].map(d => [d.lat, d.lng]);
            L.polyline(pts, { color: color, weight: 3 }).addTo(layers[key]);

            const triHtml = `<div style="color:${color};font-size:16px;transform:translate(-2px,-9px)">▲</div>`;
            L.marker(pts[0], { icon: L.divIcon({ className: '', html: triHtml }) }).addTo(layers[key]);
            const sqHtml = `<div class="square" style="background:${color}"></div>`;
            L.marker(pts[pts.length - 1], { icon: L.divIcon({ className: '', html: sqHtml, iconSize: [10, 10] }) }).addTo(layers[key]);

            const allPts = [...dataStore.f1, ...dataStore.f2].map(d => [d.lat, d.lng]);
            if (allPts.length) map.fitBounds(L.latLngBounds(allPts));
        }

        function moveCursors(time) {
            const offset = parseFloat(document.getElementById('offset').value) || 0;
            ['f1', 'f2'].forEach(key => {
                if (!dataStore[key].length) return;
                const off = key === 'f2' ? offset : 0;
                const closest = dataStore[key].reduce((a, b) => Math.abs((b.t + off) - time) < Math.abs((a.t + off) - time) ? b : a);
                cursorMarkers[key].setLatLng([closest.lat, closest.lng]);
            });
        }

        document.getElementById('file1').onchange = e => processFit(e.target.files[0], 'f1');
        document.getElementById('file2').onchange = e => processFit(e.target.files[0], 'f2');
        document.getElementById('offset').oninput = updateChart;
    </script>
</body>

</html>