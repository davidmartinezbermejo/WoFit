<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>FIT Sync Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .header { background: #2c3e50; color: white; padding: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 1000; }
        .controls { display: flex; gap: 10px; align-items: center; }
        #map { height: 40vh; width: 100%; background: #ddd; }
        .chart-container { flex: 1; padding: 10px; background: white; min-height: 0; position: relative; }
        #metrics { display: flex; gap: 12px; flex-wrap: wrap; font-size: 11px; background: #34495e; padding: 8px; border-radius: 4px; min-height: 20px; }
        .metric-item { display: flex; align-items: center; gap: 4px; border: 1px solid #555; padding: 2px 5px; border-radius: 3px; }
        .square { width: 10px; height: 10px; border: 1px solid white; }
        #resetZoom { position: absolute; top: 15px; right: 25px; z-index: 10; padding: 5px 10px; cursor: pointer; background: #eee; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; }
        canvas { cursor: grab; }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>
    <div class="header">
        <div class="controls">
            F1: <input type="file" id="file1" style="width:130px">
            F2: <input type="file" id="file2" style="width:130px">
            Offset F2: <input type="number" id="offset" value="0" style="width:60px">
        </div>
        <div id="metrics"></div>
    </div>
    <div id="map"></div>
    <div class="chart-container">
        <button id="resetZoom">Reset Zoom</button>
        <canvas id="mainChart"></canvas>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>

    <script type="module">
        import { Decoder, Stream } from 'https://cdn.jsdelivr.net/npm/@garmin/fitsdk@21.126.0/+esm';

        // Variables
        let chart;
        let dataStore = { f1: [], f2: [] };
        const paramColors = { heartRate: '#ff0000', speed: '#0000ff', cadence: '#ffff00', power: '#a020f0', altitude: '#00ff00' };

        const formatTime = (s) => {
            const abs = Math.abs(s);
            const h = Math.floor(abs / 3600);
            const m = Math.floor((abs % 3600) / 60);
            const sec = Math.floor(abs % 60);
            return `${s < 0 ? '-' : ''}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        };

        // Mapa
        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        const layers = { f1: L.featureGroup().addTo(map), f2: L.featureGroup().addTo(map) };
        const cursors = {
            f1: L.circleMarker([0,0], {color: 'blue', radius: 6, fillOpacity: 1}).addTo(map),
            f2: L.circleMarker([0,0], {color: 'red', radius: 6, fillOpacity: 1}).addTo(map)
        };

        // Gráfica
        const ctx = document.getElementById('mainChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: { datasets: [] },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: { x: { type: 'linear', ticks: { callback: v => formatTime(v) } } },
                plugins: {
                    zoom: {
                        pan: { enabled: true, mode: 'x', threshold: 5 },
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
                    },
                    tooltip: {
                        callbacks: {
                            title: (items) => formatTime(items[0].parsed.x),
                            footer: (items) => {
                                const t = items[0].parsed.x;
                                const off = parseFloat(document.getElementById('offset').value) || 0;
                                const selected = Array.from(document.querySelectorAll('#metrics input:checked')).map(i => i.value);
                                return selected.map(m => {
                                    if (!dataStore.f1.length || !dataStore.f2.length) return "";
                                    const v1 = dataStore.f1.reduce((a, b) => Math.abs(a.t - t) < Math.abs(b.t - t) ? a : b)[m] || 0;
                                    const v2 = dataStore.f2.reduce((a, b) => Math.abs((a.t + off) - t) < Math.abs((b.t + off) - t) ? a : b)[m] || 0;
                                    return `Diff ${m}: ${(v1 - v2).toFixed(1)}`;
                                }).filter(l => l !== "").join('\n');
                            },
                            afterBody: (items) => { moveCursors(items[0].parsed.x); return ""; }
                        }
                    }
                }
            }
        });

        // Funciones (Resumen)
        async function processFit(file, key) {
            if (!file) return;
            const buffer = await file.arrayBuffer();
            const decoder = new Decoder(Stream.fromByteArray(new Uint8Array(buffer)));
            const { messages } = decoder.read();
            const records = (messages.recordMesgs || []).filter(m => m.positionLat);
            if (!records.length) return;
            const startT = records[0].timestamp.getTime();
            dataStore[key] = records.map(m => {
                const obj = { t: (m.timestamp.getTime() - startT) / 1000, lat: m.positionLat * (180/2147483648), lng: m.positionLong * (180/2147483648) };
                for (let k in m) if (typeof m[k] === 'number') obj[k] = m[k];
                return obj;
            });
            drawRoute(key); buildMetricSelectors(); updateChart();
        }

        function buildMetricSelectors() {
            const div = document.getElementById('metrics');
            const checked = Array.from(div.querySelectorAll('input[type="checkbox"]:checked')).map(i => i.value);
            div.innerHTML = '';
            const keys = new Set();
            [...dataStore.f1, ...dataStore.f2].forEach(r => Object.keys(r).forEach(k => { if(!['t','lat','lng'].includes(k)) keys.add(k); }));
            Array.from(keys).sort().forEach(m => {
                if (!paramColors[m]) paramColors[m] = '#999999';
                const span = document.createElement('span');
                span.className = 'metric-item'; span.style.color = paramColors[m];
                span.innerHTML = `<input type="checkbox" value="${m}" ${checked.includes(m) || m === 'heartRate' ? 'checked' : ''}><input type="color" value="${paramColors[m]}" style="width:20px;height:20px;border:none;padding:0;background:none"><span>${m}</span>`;
                span.querySelector('input[type="checkbox"]').onchange = updateChart;
                span.querySelector('input[type="color"]').oninput = (e) => { paramColors[m] = e.target.value; span.style.color = e.target.value; updateChart(); };
                div.appendChild(span);
            });
        }

        function updateChart() {
            const off = parseFloat(document.getElementById('offset').value) || 0;
            const selected = Array.from(document.querySelectorAll('#metrics input[type="checkbox"]:checked')).map(i => i.value);
            chart.data.datasets = [];
            const scales = { x: { type: 'linear', ticks: { callback: v => formatTime(v) } } };
            selected.forEach((m, i) => {
                const color = paramColors[m];
                scales[m] = { type: 'linear', display: true, position: i % 2 === 0 ? 'left' : 'right', title: { display: true, text: m, color: color }, ticks: { color: color }, grid: { drawOnChartArea: i === 0 } };
                ['f1', 'f2'].forEach(key => {
                    if (dataStore[key].length) chart.data.datasets.push({ label: `${key.toUpperCase()}: ${m}`, data: dataStore[key].map(d => ({ x: d.t + (key==='f2'?off:0), y: d[m] })), borderColor: color, yAxisID: m, pointRadius: 0, borderWidth: 2, borderDash: key==='f2'?[5,5]:[] });
                });
            });
            chart.options.scales = scales; chart.update();
        }

        function drawRoute(key) {
            layers[key].clearLayers();
            const color = key === 'f1' ? 'blue' : 'red';
            const pts = dataStore[key].map(d => [d.lat, d.lng]);
            L.polyline(pts, { color: color, weight: 3 }).addTo(layers[key]);
            L.marker(pts[0], { icon: L.divIcon({ className: '', html: `<div style="color:${color};font-size:16px;transform:translate(-2px,-9px)">▲</div>` }) }).addTo(layers[key]);
            L.marker(pts[pts.length - 1], { icon: L.divIcon({ className: '', html: `<div class="square" style="background:${color}"></div>`, iconSize: [10, 10] }) }).addTo(layers[key]);
            const allPts = [...dataStore.f1, ...dataStore.f2].map(d => [d.lat, d.lng]);
            if (allPts.length) map.fitBounds(L.latLngBounds(allPts));
        }

        function moveCursors(t) {
            const off = parseFloat(document.getElementById('offset').value) || 0;
            ['f1', 'f2'].forEach(key => {
                if (!dataStore[key].length) return;
                const o = key === 'f2' ? off : 0;
                const c = dataStore[key].reduce((a, b) => Math.abs((a.t + o) - t) < Math.abs((b.t + o) - t) ? a : b);
                cursors[key].setLatLng([c.lat, c.lng]);
            });
        }

        document.getElementById('file1').onchange = e => processFit(e.target.files[0], 'f1');
        document.getElementById('file2').onchange = e => processFit(e.target.files[0], 'f2');
        document.getElementById('offset').oninput = updateChart;
        document.getElementById('resetZoom').onclick = () => chart.resetZoom();
    </script>
</body>
</html>